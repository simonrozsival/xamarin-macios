using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Xamarin.ManagedRegistrarGenerator
{
	[Generator(LanguageNames.CSharp)]
	public class ManagedRegistrarGenerator : IIncrementalGenerator
	{
		private sealed record RegisteredClass(RegisteredClassInfo ClassInfo, ClassDeclarationSyntax Syntax);
		
		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			var unsafeCodeIsEnabled = context.CompilationProvider.Select((comp, ct) => comp.Options is CSharpCompilationOptions { AllowUnsafe: true });
			var registeredClassesOrDiagnostics = context.SyntaxProvider
				.CreateSyntaxProvider(
					predicate: (node, _) => node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 },
					transform: GetRegisteredClass)
				.Where(static registeredClass => registeredClass is not null)
				.Combine(unsafeCodeIsEnabled)
				.Select((data, cancellationToken) =>
					{
						RegisteredClass registeredClass = data.Left!;
						bool unsafeCodeIsEnabled = data.Right;

						// TODO collect all diagnostics into an array instead of failing fast?

						if (!unsafeCodeIsEnabled)
						{
							return DiagnosticOr<RegisteredClass>.FromDiagnostic(
								Diagnostic.Create(
									GeneratorDiagnostics.RequiresAllowUnsafeBlocks,
									registeredClass.Syntax.Identifier.GetLocation()));
						}

						// TODO if it's a nested class all of the parent classes must be partial
						if (!registeredClass.Syntax.Modifiers.Any(SyntaxKind.PartialKeyword))
						{
							return DiagnosticOr<RegisteredClass>.FromDiagnostic(
								Diagnostic.Create(
									GeneratorDiagnostics.InvalidAttributedClassMissingPartialModifier,
									registeredClass.Syntax.Identifier.GetLocation(),
									registeredClass.ClassInfo.Type.ToDisplayString()));
						}

						if (!IsNSObject(registeredClass.ClassInfo.Type, cancellationToken))
						{
							if (registeredClass.ClassInfo.Attribute is not null)
							{
								return DiagnosticOr<RegisteredClass>.FromDiagnostic(
									Diagnostic.Create(
										GeneratorDiagnostics.InvalidAttributedClassMissingPartialModifier,
										registeredClass.Syntax.Identifier.GetLocation(),
										registeredClass.ClassInfo.Type.ToDisplayString()));
							}
						}

						// TODO if it's a generic type, check the constraints on the generic params
						// if they're constrained to NSObject

						// TODO validate that all exported methods have a selector

						return DiagnosticOr<RegisteredClass>.FromValue(registeredClass);
					});

			var (diagnostics, registeredClasses) = DiagnosticOr<RegisteredClass>.Split(registeredClassesOrDiagnostics);
			context.RegisterSourceOutput(diagnostics, (context, diagnostic) => context.ReportDiagnostic(diagnostic));

			// TODO implement configuration
			// var configurationProvider = context.AnalyzerConfigOptionsProvider
			// 	.Select(static (configuration, _) => Configuration.From(configuration.GlobalOptions));

			var combinedProvider = context.CompilationProvider
				.Combine(registeredClasses.Collect());
				// .Combine(configurationProvider);

			context.RegisterSourceOutput(combinedProvider,
				static (context, valueProvider) => 
				{
					// TODO deduplicate registered classes
					var compilation = valueProvider.Left;
					var registeredClasses = valueProvider.Right;
					// Configuration configuration = valueProvider.Right;

					var generatedMembers = new List<MemberDeclarationSyntax>();
					foreach (var registeredClass in registeredClasses) {
						var managedCodeGenerator = new ManagedCodeGenerator(registeredClass.ClassInfo);
						generatedMembers.Add(managedCodeGenerator.Generate(context.CancellationToken));

						var nativeCodeGenerator = new NativeCodeGenerator(registeredClass.ClassInfo);
						// TODO
						var outputDirectory = "/Users/simonrozsival/Projects/xamarin/xamarin-macios/tools/source-generators/dump";

						// https://github.com/dotnet/roslyn/issues/57608
						// TODO cancellation token? async?
						File.WriteAllText(
							path: Path.Combine(outputDirectory, nativeCodeGenerator.HeaderFileName),
							contents: nativeCodeGenerator.GenerateHeader(context.CancellationToken),
							encoding: Encoding.UTF8);

						File.WriteAllText(
							path: Path.Combine(outputDirectory, nativeCodeGenerator.ImplementationFileName),
							contents: nativeCodeGenerator.GenerateImplementation(context.CancellationToken),
							encoding: Encoding.UTF8);
					}

					var sourceCode = $"""
						// <auto-generated />

						// registered classes: {generatedMembers.Count}

						{SyntaxFactory.CompilationUnit().AddMembers(generatedMembers.ToArray()).NormalizeWhitespace()}
						""";

					context.AddSource("ManagedRegistrar.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
				});
		}

		private static RegisteredClass? GetRegisteredClass(GeneratorSyntaxContext context, CancellationToken cancellationToken)
		{
			var classDeclaration = (ClassDeclarationSyntax)context.Node;
			INamedTypeSymbol? classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
			if (classSymbol is null)
			{
				return null;
			}

			if (!IsNSObject(classSymbol, cancellationToken))
			{
				return null;
			}

			var classInfo = RegisteredClassInfo.GetRegisteredClassInfo(classSymbol, cancellationToken);
			return new RegisteredClass(classInfo, classDeclaration);
		}

		// TODO revisit this method
		private static bool IsNSObject(INamedTypeSymbol? type, CancellationToken cancellationToken)
		{
			while (type is not null)
			{
				cancellationToken.ThrowIfCancellationRequested();

				if (type.Name == "NSObject"
					&& type.ContainingNamespace?.Name == "Foundation"
					&& type.ContainingType is null)
				{
					return true;
				}

				type = type.BaseType;
			}

			return false;
		}
	}
}
