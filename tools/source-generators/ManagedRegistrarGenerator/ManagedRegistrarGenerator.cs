using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Xamarin.ManagedRegistrarGenerator
{
	[Generator(LanguageNames.CSharp)]
	public class ManagedRegistrarGenerator : IIncrementalGenerator
	{
		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			var unsafeCodeIsEnabled = context.CompilationProvider.Select((comp, ct) => comp.Options is CSharpCompilationOptions { AllowUnsafe: true });
			var registeredClassesOrDiagnostics = context.SyntaxProvider
				.CreateSyntaxProvider(
					predicate: (node, _) => node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 },
					transform: GetRegisteredClassInfo)
				.Where(static registeredClassInfo => registeredClassInfo is not null)
				.Combine(unsafeCodeIsEnabled)
				.Select((data, _) =>
					{
						RegisteredClassInfo registeredClassInfo = data.Left!;
						bool unsafeCodeIsEnabled = data.Right;

						// TODO collect all diagnostics into an array instead of failing fast?

						if (!unsafeCodeIsEnabled)
						{
							return DiagnosticOr<RegisteredClassInfo>.FromDiagnostic(
								Diagnostic.Create(
									GeneratorDiagnostics.RequiresAllowUnsafeBlocks,
									registeredClassInfo.Syntax.Identifier.GetLocation()));
						}

						// TODO if it's a nested class all of the parent classes must be partial
						if (!registeredClassInfo.Syntax.Modifiers.Any(SyntaxKind.PartialKeyword))
						{
							return DiagnosticOr<RegisteredClassInfo>.FromDiagnostic(
								Diagnostic.Create(
									GeneratorDiagnostics.InvalidAttributedClassMissingPartialModifier,
									registeredClassInfo.Syntax.Identifier.GetLocation(),
									registeredClassInfo.Type.ToDisplayString()));
						}

						// TODO if it's a generic type, check the constraints on the generic params
						// if they're constrained to NSObject

						// TODO validate that all exported methods have a selector

						return DiagnosticOr<RegisteredClassInfo>.FromValue(registeredClassInfo);
					});

			var (diagnostics, registeredClasses) = DiagnosticOr<RegisteredClassInfo>.Split(registeredClassesOrDiagnostics);
			context.RegisterSourceOutput(diagnostics, (context, diagnostic) => context.ReportDiagnostic(diagnostic));

			// TODO implement configuration
			// var configurationProvider = context.AnalyzerConfigOptionsProvider
			// 	.Select(static (configuration, _) => Configuration.From(configuration.GlobalOptions));

			var combinedProvider = context.CompilationProvider
				.Combine(registeredClasses.Collect());
				// .Combine(configurationProvider);

			context.RegisterSourceOutput(combinedProvider,
				static (context, valueProvider) => 
				{
					try
					{
					// TODO deduplicate registered classes
					var compilation = valueProvider.Left;
					var registeredClasses = valueProvider.Right;
					// Configuration configuration = valueProvider.Right;

					var compilationUnit = SyntaxFactory.ParseCompilationUnit(
						"""
						// <auto-generated />
						#nullable enable

						using System;
						""");

					var generatedMembers = new List<MemberDeclarationSyntax>();
					foreach (var registeredClass in registeredClasses) {
						var managedCodeGenerator = new ManagedCodeGenerator(registeredClass);
						generatedMembers.Add(managedCodeGenerator.Generate(context.CancellationToken));

						// var nativeCodeGenerator = new NativeCodeGenerator(registeredClass);

						// // https://github.com/dotnet/roslyn/issues/57608
						// // TODO cancellation token? async?
						// File.WriteAllText(
						// 	path: Path.Combine(configuration.NativeCodeOutputDirectory, "ManagedRegistrar.mm"),
						// 	contents: nativeCodeGenerator.GenerateImplementation(context.CancellationToken),
						// 	encoding: Encoding.UTF8);

						// File.WriteAllText(
						// 	path: Path.Combine(configuration.NativeCodeOutputDirectory, "ManagedRegistrar.h"),
						// 	contents: nativeCodeGenerator.GenerateImplementation(context.CancellationToken),
						// 	encoding: Encoding.UTF8);
					}

					var sourceCode = compilationUnit.WithMembers(new(generatedMembers)).NormalizeWhitespace().ToString();
					context.AddSource("ManagedRegistrar.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
					}
					catch (Exception ex)
					{
						throw new Exception(ex.Message + " " + ex.StackTrace, ex);
					}
				});
		}

		private static RegisteredClassInfo? GetRegisteredClassInfo(GeneratorSyntaxContext context, CancellationToken cancellationToken)
		{
			var classDeclaration = (ClassDeclarationSyntax)context.Node;
			INamedTypeSymbol? classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
			if (classSymbol is null)
				return null;

			// If the class has the [Register] attribute, we should skip registering that class if it is a wrapper
			// or if the "skip registration" flag is set. If there isn't any attribute, we will always register it.
			_ = TryGetRegisterAttribute(classSymbol, out var attributeData);

			if (!IsNSObject(classSymbol, cancellationToken))
			{
				if (attributeData is not null)
				{
					// TODO report an error
				}

				return null;
			}

			var isWrapper = attributeData is not null && (attributeData.IsWrapper || attributeData.SkipRegistration); // TODO I need to check again what SkipRegistration actually means and how it's different
			var exportedMembers = !isWrapper
				? GetExportedMembers(classSymbol, cancellationToken).ToArray()
				: Array.Empty<ExportedMemberInfo>();

			return new RegisteredClassInfo(
				classSymbol, classDeclaration, attributeData, exportedMembers);
		}

		// TODO revisit this method
		private static bool IsNSObject(INamedTypeSymbol? type, CancellationToken cancellationToken)
		{
			while (type is not null)
			{
				cancellationToken.ThrowIfCancellationRequested();

				if (type.ToDisplayString() == "Foundation.NSObject") // TODO extract constant
				{
					return true;
				}

				type = type.BaseType;
			}

			return false;
		}

		private static bool TryGetRegisterAttribute(
			INamedTypeSymbol type,
			out RegisterAttributeData? attributeData)
		{
			AttributeData? attribute = type.GetAttributes().FirstOrDefault(IsRegisterAttribute);
			attributeData = GetRegisterAttributeData(attribute);
			return attributeData is not null;

			static bool IsRegisterAttribute(AttributeData attribute)
				=> attribute.AttributeClass?.ToDisplayString() == "Foundation.RegisterAttribute"; // TODO extract constant

			static RegisterAttributeData? GetRegisterAttributeData(AttributeData? attribute)
			{
				if (attribute is null)
					return null;

				var name = attribute.ConstructorArguments.Length > 0
					? attribute.ConstructorArguments[0].Value as string
					: attribute.NamedArguments.FirstOrDefault(static arg => arg.Key == "Name").Value.Value as string;
				var isWrapper = attribute.ConstructorArguments.Length > 1
					? attribute.ConstructorArguments[1].Value as bool?
					: attribute.NamedArguments.FirstOrDefault(static arg => arg.Key == "IsWrapper").Value.Value as bool?;
				var skipRegistration = attribute.NamedArguments.FirstOrDefault(static arg => arg.Key == "SkipRegistration").Value.Value as bool?;

				return new RegisterAttributeData(
					name ?? string.Empty,
					isWrapper ?? false,
					skipRegistration ?? false);
			}
		}

		private static IEnumerable<ExportedMemberInfo> GetExportedMembers(INamedTypeSymbol type, CancellationToken cancellationToken)
		{
			foreach (ISymbol member in type.GetMembers())
			{
				if (TryGetExportAttribute(member, out ExportAttributeData? attributeData) && attributeData is not null)
				{
					yield return new ExportedMemberInfo(member, attributeData);
				}
				else if (member is IMethodSymbol method
					&& method.MethodKind == MethodKind.Constructor
					&& !type.IsAbstract // TODO the Mono.Cecil code doesn't remove ctors of abstract classes
					&& !method.IsStatic
					&& method.Parameters.Length == 0)
				{
					// the parameterless constructor is special
					yield return new ExportedMemberInfo(
						member, new ExportAttributeData(Selector: "init", ArgumentSemantic: -1, IsVariadic: false));
				}
			}
		}

		private static bool TryGetExportAttribute(
			ISymbol member,
			out ExportAttributeData? attributeData)
		{
			AttributeData? attribute = member.GetAttributes().FirstOrDefault(IsExportAttribute);
			if (attribute is null
				&& member is IMethodSymbol method
				&& method.OverriddenMethod is IMethodSymbol overriddenMethod)
			{
				return TryGetExportAttribute(overriddenMethod, out attributeData);
			}

			attributeData = GetExportAttributeData(attribute);
			return attributeData is not null;

			static bool IsExportAttribute(AttributeData attribute)
				=> attribute.AttributeClass?.ToDisplayString() == "Foundation.ExportAttribute"; // TODO extract constant

			static ExportAttributeData? GetExportAttributeData(AttributeData? attribute)
			{
				if (attribute is null)
					return null;

				var selector = attribute.ConstructorArguments.Length > 0
					? attribute.ConstructorArguments[0].Value as string
					: attribute.NamedArguments.FirstOrDefault(static arg => arg.Key == "Selector").Value.Value as string;
				var argumentSemantic = attribute.ConstructorArguments.Length > 1
					? attribute.ConstructorArguments[1].Value as int?
					: attribute.NamedArguments.FirstOrDefault(static arg => arg.Key == "ArgumentSemantic").Value.Value as int?;
				var isVariadic = attribute.NamedArguments.FirstOrDefault(static arg => arg.Key == "IsVariadic").Value.Value as bool?;

				if (selector is null)
				{
					// TODO report diagnostic instead
					throw new ArgumentException($"Export attribute is missing selector");
				}

				return new ExportAttributeData(
					selector,
					argumentSemantic ?? -1, // TODO ArgumentSemantic.None == -1
					isVariadic ?? false);
			}
		}
	}
}
